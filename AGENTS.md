# Project-specific AI guidance

## Build and Development Workflow

### Build Process

This project uses Webpack to build TypeScript and WGSL shaders into a static HTML application. You must specify which example to build using the `--env example=` flag:

```bash
npm run build -- --env example=game-of-life      # Build game-of-life to dist/
npm start -- --env example=game-of-life          # Start dev server for game-of-life
```

**Important**:
- The `--env example=` flag is **required** - running `npm run build` without it will show an error with available examples
- The final output is a **static HTML file** at `dist/index.html`, along with bundled JavaScript
- Webpack automatically discovers all examples in `src/examples/` directory

### Project Structure

This template is organized around **examples** - each example is a complete, self-contained WebGPU simulation:

```
src/
├── utils.ts              # Shared WebGPU utilities (setupTextures, mouse/touch handling)
├── index.html            # HTML template (processed by webpack)
├── assets/               # Static assets (images, favicon, etc.)
└── examples/             # Example simulations (each is self-contained)
    └── game-of-life/
        ├── index.ts      # Main entry point for this example
        ├── README.md     # Documentation for this specific example
        └── shaders/
            ├── compute.wgsl      # Compute shader
            ├── render.wgsl       # Render shader (vertex + fragment)
            └── includes/         # Shared WGSL code (imported via #import)
                ├── bindings.wgsl       # Binding layout definitions
                ├── textures.wgsl       # Texture declarations
                └── interactions.wgsl   # Interaction structs (optional)

dist/                     # Built output (generated by webpack)
├── index.html            # Final HTML (includes bundled scripts)
├── index.bundle.js       # Bundled application code
└── runtime.bundle.js     # Webpack runtime
```

### Adding New Examples

To create a new example simulation:

1. **Create directory structure**:
   ```bash
   mkdir -p src/examples/my-simulation/shaders/includes
   ```

2. **Create required files**:
   - `src/examples/my-simulation/index.ts` - Main entry point
   - `src/examples/my-simulation/README.md` - Documentation
   - `src/examples/my-simulation/shaders/compute.wgsl` - Compute shader
   - `src/examples/my-simulation/shaders/render.wgsl` - Render shader
   - `src/examples/my-simulation/shaders/includes/bindings.wgsl` - Bindings
   - `src/examples/my-simulation/shaders/includes/textures.wgsl` - Textures

3. **Build it**:
   ```bash
   npm run build -- --env example=my-simulation
   ```

**That's it!** Webpack automatically discovers all examples in `src/examples/` - no need to modify `package.json` or any configuration files.

**Reference the game-of-life example** as a template for structure and patterns.


## Testing and Validation

### Automated Capture Tool

After making code changes, use the capture tool to verify the simulation works:

```bash
# Build the example first
npm run build -- --env example=game-of-life

# Standard capture (10 screenshots at 500ms intervals)
npm run capture

# Custom capture with explicit arguments
npm run capture -- --screenshots 5 --interval 1000
```

Check `.capture/session-[timestamp]/` for results
**What gets captured**:

- Console output (logs, warnings, errors)
- Multiple screenshots showing animation over time
- JSON summary with error analysis

**Output location**: `.capture/session-[timestamp]/`

### When to Use Capture Tool

**Always capture after**:

- Modifying shaders (compute.wgsl, render.wgsl)
- Changing simulation logic (index.ts)
- Updating WebGPU initialization (utils.ts)
- Making any code changes that affect rendering

**Why**: The capture tool runs in a real Chrome browser with WebGPU support, catching:

- Shader compilation errors
- WebGPU API usage errors
- Runtime errors that don't show up during build
- Visual verification that the simulation actually renders

### Expected Console Output

A healthy simulation should show:

```
✓ [INFO] [webpack-dev-server] Server started...
✓ [LOG] [HMR] Waiting for update signal from WDS...
✓ [INFO] WebGPU is experimental on this platform...
```

**Common errors to watch for**:

- `Failed to load resource: 404` - Wrong URL or missing file
- `Shader compilation failed` - WGSL syntax errors
- `WebGPU not supported` - Browser compatibility issue
- `TypeError` - JavaScript errors in your code
- **Console warnings are actually often critical shader errors**.

### WebGPU Screenshot and Console Capture

**The capture tool opens a visible browser by default** so WebGPU screenshots work correctly:

- Opens `dist/index.html` directly using `file://` protocol
- No dev server needed
- Screenshots capture the actual rendered output
- Console logs are also captured for debugging

**Note**: WebGPU does not render in headless Chrome, so screenshots would be black in headless mode. The default non-headless mode ensures screenshots work out of the box.

### Verifying Captures

```bash
# Check console logs for errors
cat .capture/session-*/console.log

# View error summary as JSON
jq '.errors' .capture/session-*/summary.json

# View screenshots (in any image viewer)
open .capture/session-*/frame-0002.png
```

### Development Server

This is typically used by humans for interactive debugging sessions and visualizing hot-reloaded code changes. **Do NOT run `npm start`** unless explicitly requested - The development server is for human interactive debugging and visualization only. The capture tool provides everything needed for automated validation.

## Architecture Principles

### Includes System for Shared WGSL Code

The template uses a custom `#import` system to eliminate duplication and maintain a single source of truth:

**How it works**:
1. **Define once** in `src/shaders/includes/bindings.wgsl` - Binding indices and layout structures
2. **Declare once** in `src/shaders/includes/textures.wgsl` - Texture variables with their bindings
3. **Import everywhere** using `#import includes::bindings` and `#import includes::textures`

**Benefits**:
- **No duplication**: Binding indices defined once, used everywhere
- **Type safety**: WGSL structures ensure consistency between TS and shaders
- **Easy refactoring**: Change binding index in one place, updates everywhere
- **Clear contracts**: The includes files document the full binding interface

**Example workflow**:
```wgsl
// In compute.wgsl or render.wgsl
#import includes::bindings  // Gets BINDINGS constants
#import includes::textures  // Gets texture variable declarations

// Now you can use: states, velocities, etc.
let value = textureLoad(states, pos, 0);
```

### setupTextures Utility Simplifies Texture Management

The `setupTextures()` function in `utils.ts` automates texture creation, data upload, and binding layout setup:

**What it handles automatically**:
- Creates GPU textures with correct usage flags (`STORAGE_BINDING | TEXTURE_BINDING | COPY_DST`)
- Initializes textures with provided data or zeros
- Configures 2D vs 2D-array based on `depthOrArrayLayers` parameter
- Sets up binding layouts for bind groups
- Handles multi-channel formats (r32float, rg32float, rgba32float, r32uint, etc.)
- Creates canvas size buffer for shader access to dimensions

**How to add a new texture** (within an example):
1. Update `src/examples/{example}/shaders/includes/bindings.wgsl` with new binding index
2. Update `src/examples/{example}/shaders/includes/textures.wgsl` with new texture declaration
3. Update TypeScript `BINDINGS` object in `src/examples/{example}/index.ts`
4. Add texture to `setupTextures()` call with initial data, layers, and format

**No manual bind group layout creation needed** - the utility generates everything from your configuration.

**Example from game-of-life**:
```typescript
// In src/examples/game-of-life/index.ts
const BINDINGS = {
  CANVAS: 0,
  CONTROLS: 1,
  INTERACTIONS: 2,
  STATES: 3,
  NEIGHBORS: 4,
};

const { textures, layouts } = setupTextures(device, canvas, [
  { data: initialStates, layers: 2, format: "r32uint" },  // STATES
  { data: null, layers: 2, format: "r32uint" },           // NEIGHBORS
]);
```

## Coding practices

### General

- Self-documenting code. Prefer clear naming of variables and functions. In most cases the logic of the program is evident from control flow and variable names so **do NOT comment code** unless absolutely necessary.

### WebGPU

- Prefer using `texture_2d_array` for multiple simulation layers
- Use the includes system for all binding definitions - no hardcoded binding indices
- Use `setupTextures()` utility for texture creation - handles all boilerplate automatically

### WebGPU Storage Texture Constraints

**CRITICAL**: WebGPU only supports `read_write` storage textures for single-channel formats:

**Supported for read_write**:
- `r32float`, `r32uint`, `r32sint` ✅

**NOT supported for read_write**:
- `rgba32float`, `rg32float`, `rgba8unorm`, etc. ❌

**Design pattern for multi-channel data**:
- Use `texture_storage_2d_array<r32float, read_write>` with separate layers for each component
- Example: velocity field with x,y components → 2-layer texture (layer 0 = x, layer 1 = y)
- Example: RGB color → 3-layer texture (layer 0 = r, layer 1 = g, layer 2 = b)
- Access with `textureLoad(texture, coords, layer)` and `textureStore(texture, coords, layer, value)`

**Do NOT create separate textures** for each component - this wastes binding slots and is inefficient
